var documenterSearchIndex = {"docs":
[{"location":"guide/#Usage-Guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"guide/#Installation","page":"Usage Guide","title":"Installation","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Use the Julia package manager.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"julia> using Pkg\njulia> Pkg.add(\"PrettyPrinting\")","category":"page"},{"location":"guide/#Using-PrettyPrinting","page":"Usage Guide","title":"Using PrettyPrinting","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"First, import the module.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"using PrettyPrinting","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Use the function pprint() to print composite data structures formed of nested tuples, vectors, and dictionaries.  The data will be formatted to fit the screen size.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To demonstrate how to use pprint(), we take a small dataset of city departments with associated employees.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"data = [(name = \"POLICE\",\n         employees = [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n                      (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]),\n        (name = \"OEMC\",\n         employees = [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n                      (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)])]","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The built-in print() function prints this data on a single line, making the output unreadable.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"print(data)\n#-> NamedTuple … [(name = \"POLICE\", employees = NamedTuple{ … }[(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing), … ]) … ]","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"By contrast, pprint() formats the data to fit the screen size.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprint(data)\n#=>\n[(name = \"POLICE\",\n  employees = [(name = \"JEFFERY A\",\n                position = \"SERGEANT\",\n                salary = 101442,\n                rate = missing),\n               (name = \"NANCY A\",\n                position = \"POLICE OFFICER\",\n                salary = 80016,\n                rate = missing)]),\n (name = \"OEMC\",\n  employees = [(name = \"LAKENYA A\",\n                position = \"CROSSING GUARD\",\n                salary = missing,\n                rate = 17.68),\n               (name = \"DORIS A\",\n                position = \"CROSSING GUARD\",\n                salary = missing,\n                rate = 19.38)])]\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The width of the output is controlled by the displaysize property of the output stream.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprint(IOContext(stdout, :displaysize => (24, 100)), data)\n#=>\n[(name = \"POLICE\",\n  employees = [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n               (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]),\n (name = \"OEMC\",\n  employees = [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n               (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)])]\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To add a line break after the output, use the function pprintln().","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprintln(data[1])\npprintln(data[2])\n#=>\n(name = \"POLICE\",\n employees = [(name = \"JEFFERY A\",\n               position = \"SERGEANT\",\n               salary = 101442,\n               rate = missing),\n              (name = \"NANCY A\",\n               position = \"POLICE OFFICER\",\n               salary = 80016,\n               rate = missing)])\n(name = \"OEMC\",\n employees = [(name = \"LAKENYA A\",\n               position = \"CROSSING GUARD\",\n               salary = missing,\n               rate = 17.68),\n              (name = \"DORIS A\",\n               position = \"CROSSING GUARD\",\n               salary = missing,\n               rate = 19.38)])\n=#","category":"page"},{"location":"guide/#Formatting-Julia-Code","page":"Usage Guide","title":"Formatting Julia Code","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"PrettyPrinting can format Julia code represented as an Expr object.  It supports a fair subset of Julia syntax including top-level declarations, statements, and expressions.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"ex = quote\n    fib(n::Number) = n > 1 ? fib(n-1) + fib(n-2) : n\n    @show fib(10)\nend\n\npprint(ex)\n#=>\nquote\n    fib(n::Number) = n > 1 ? fib(n - 1) + fib(n - 2) : n\n    @show fib(10)\nend\n=#","category":"page"},{"location":"guide/#Extending-PrettyPrinting","page":"Usage Guide","title":"Extending PrettyPrinting","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"It is customary to display a Julia object as a valid Julia expression that constructs the object.  The ability of pprint() to format Julia code makes it easy to implement this functionality for user-defined types.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"For example, consider the following hierarchical data type.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"struct Node\n    name::Symbol\n    arms::Vector{Node}\nend\n\nNode(name) = Node(name, [])","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Let us create a nested tree of this type.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"tree =\n    Node(:a, [Node(:an, [Node(:anchor, [Node(:anchorage),\n                                        Node(:anchorite)]),\n                         Node(:anchovy),\n                         Node(:antic, [Node(:anticipation)])]),\n              Node(:arc, [Node(:arch, [Node(:archduke),\n                                       Node(:archer)])]),\n              Node(:awl)])\n#-> Node(:a, DocsSrcGuideMd.Node[ … ])","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To make pprint() format this tree, we need to implement the function quoteof(::Node), which should return an Expr object.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"import PrettyPrinting: quoteof\n\nquoteof(n::Node) =\n    if isempty(n.arms)\n        :(Node($(quoteof(n.name))))\n    else\n        :(Node($(quoteof(n.name)), $(quoteof(n.arms))))\n    end","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"That's it!  Now pprint() displays a nicely formatted Julia expression that represents the tree.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprint(tree)\n#=>\nNode(:a,\n     [Node(:an,\n           [Node(:anchor, [Node(:anchorage), Node(:anchorite)]),\n            Node(:anchovy),\n            Node(:antic, [Node(:anticipation)])]),\n      Node(:arc, [Node(:arch, [Node(:archduke), Node(:archer)])]),\n      Node(:awl)])\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can even override show() to make it display this representation.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Base.show(io::IO, ::MIME\"text/plain\", n::Node) =\n    pprint(io, n)\n\ndisplay(tree)\n#=>\nNode(:a,\n     [Node(:an,\n           [Node(:anchor, [Node(:anchorage), Node(:anchorite)]),\n            Node(:anchovy),\n            Node(:antic, [Node(:anticipation)])]),\n      Node(:arc, [Node(:arch, [Node(:archduke), Node(:archer)])]),\n      Node(:awl)])\n=#","category":"page"},{"location":"guide/#Layout-Expressions","page":"Usage Guide","title":"Layout Expressions","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Internally, PrettyPrinting represents all potential layouts of a data structure in the form of a layout expression.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We will use the following definitions.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"using PrettyPrinting: best_fit, indent, list_layout, literal, pair_layout","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"A fixed single-line layout is created with literal().","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"ll = literal(\"salary\")\n#-> literal(\"salary\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Layouts could be combined using horizontal (*) and vertical (/) composition operators.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"lhz = literal(\"salary\") * literal(\" = \") * literal(\"101442\")\n#-> literal(\"salary\") * literal(\" = \") * literal(\"101442\")\n\nlvt = literal(\"salary\") * literal(\" =\") /\n      indent(4) * literal(\"101442\")\n#-> literal(\"salary\") * literal(\" =\") / indent(4) * literal(\"101442\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Here, indent(4) is equivalent to literal(\" \"^4).","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Function pprint() serializes the layout.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprint(ll)\n#-> salary\n\npprint(lhz)\n#-> salary = 101442\n\npprint(lvt)\n#=>\nsalary =\n    101442\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To indicate that we can choose between several different layouts, we use the choice (|) operator.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"l = lhz | lvt\n#=>\nliteral(\"salary\") * literal(\" = \") * literal(\"101442\") |\nliteral(\"salary\") * literal(\" =\") / indent(4) * literal(\"101442\")\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The pretty-printing engine can search through all potential layouts to find the best fit, which is expressed as a layout expression without the choice operator.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"best_fit(l)\n#-> literal(\"salary\") * (literal(\" = \") * literal(\"101442\"))","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"In addition to the primitive operations, PrettyPrinting can generate some common layouts.  A delimiter-separated pair can be generated with pair_layout().","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pair_layout(literal(\"salary\"), literal(\"101442\"), sep=\" = \")\n#=>\n(literal(\"salary\") * literal(\" = \") |\n literal(\"salary\") * literal(\" =\") / indent(4)) *\nliteral(\"101442\")\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"A delimiter-separated list of items can be generated with list_layout().","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"list_layout([literal(\"salary = 101442\"), literal(\"rate = missing\")])\n#=>\n(literal(\"(\") | literal(\"(\") / indent(4)) *\n(literal(\"salary = 101442\") * literal(\",\") / literal(\"rate = missing\")) *\nliteral(\")\") |\nliteral(\"(\") *\n(literal(\"salary = 101442\") * literal(\", \") * literal(\"rate = missing\")) *\nliteral(\")\")\n=#","category":"page"},{"location":"guide/#Custom-Layouts","page":"Usage Guide","title":"Custom Layouts","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can customize how pprint() formats objects of a user-defined type by implementing function tile(), which should map an object to the corresponding layout expression.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Continuing with the type Node defined in section Extending PrettyPrinting, let us give it a custom layout generated with list_layout().","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"import PrettyPrinting: tile\n\ntile(n::Node) =\n    if isempty(n.arms)\n        literal(n.name)\n    else\n        literal(n.name) *\n        literal(\" -> \") *\n        list_layout(tile.(n.arms))\n    end","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Now pprint() will render a new representation of the tree.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"pprint(stdout, tree)\n#=>\na -> (an -> (anchor -> (anchorage, anchorite),\n             anchovy,\n             antic -> (anticipation)),\n      arc -> (arch -> (archduke, archer)),\n      awl)\n=#","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"In summary, there are two ways to customize pprint() for a user-defined type T.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Define PrettyPrinting.quoteof(::T), which should return an Expr object.\nDefine PrettyPrinting.tile(::T), which should return a layout expression.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PrettyPrinting.pprint\nPrettyPrinting.pprintln\nPrettyPrinting.quoteof\nPrettyPrinting.tile","category":"page"},{"location":"api/#PrettyPrinting.pprint","page":"API Reference","title":"PrettyPrinting.pprint","text":"pprint([io::IO], data)\n\nDisplay the data so that it fits the width of the output screen.\n\n\n\n\n\n","category":"function"},{"location":"api/#PrettyPrinting.pprintln","page":"API Reference","title":"PrettyPrinting.pprintln","text":"pprintln([io::IO], data)\n\nDisplay the data using pprint and print a line break.\n\n\n\n\n\n","category":"function"},{"location":"api/#PrettyPrinting.quoteof","page":"API Reference","title":"PrettyPrinting.quoteof","text":"quoteof(obj)\n\nConvert an object to its representation in Julia AST.\n\nImplement this method to customize pprint on a user-defined type.\n\n\n\n\n\n","category":"function"},{"location":"api/#PrettyPrinting.tile","page":"API Reference","title":"PrettyPrinting.tile","text":"tile(obj)\n\nConvert an object to the corresponding layout expression.\n\nImplement this method to customize pprint on a user-defined type.\n\n\n\n\n\n","category":"function"},{"location":"test/#Test-Suite","page":"Test Suite","title":"Test Suite","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"We start with importing the package.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"using PrettyPrinting: list_layout, literal, pair_layout, pprint, pprintln","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"The following function overrides the width of the output terminal.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"resize(w) = IOContext(stdout, :displaysize => (24, w))","category":"page"},{"location":"test/#Formatting-Built-in-Data-Structures","page":"Test Suite","title":"Formatting Built-in Data Structures","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"The function pprint() supports many built-in data structures.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"In particular, pprint() can format Pair objects.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"p = :deinstitutionalization => :counterrevolutionaries\n\npprint(p)\n#-> :deinstitutionalization => :counterrevolutionaries\n\npprint(resize(40), p)\n#=>\n:deinstitutionalization =>\n    :counterrevolutionaries\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(::Pair) can handle composite keys and values.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"p = :deinstitutionalization => [:notation, :nation, :initialization, :intuition]\n\npprint(p)\n#-> :deinstitutionalization => [:notation, :nation, :initialization, :intuition]\n\npprint(resize(60), p)\n#=>\n:deinstitutionalization =>\n    [:notation, :nation, :initialization, :intuition]\n=#\n\npprint(resize(50), p)\n#=>\n:deinstitutionalization => [:notation,\n                            :nation,\n                            :initialization,\n                            :intuition]\n=#\n\npprint(resize(40), p)\n#=>\n:deinstitutionalization =>\n    [:notation,\n     :nation,\n     :initialization,\n     :intuition]\n=#\n\np = [:orientation, :interculture, :translucent] => :counterrevolutionaries\n\npprint(p)\n#-> [:orientation, :interculture, :translucent] => :counterrevolutionaries\n\npprint(resize(60), p)\n#=>\n[:orientation, :interculture, :translucent] =>\n    :counterrevolutionaries\n=#\n\npprint(resize(40), p)\n#=>\n[:orientation,\n :interculture,\n :translucent] =>\n    :counterrevolutionaries\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint() can also format tuples and vectors.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(())\n#-> ()\n\npprint([])\n#-> []\n\npprint((:deinstitutionalization,))\n#-> (:deinstitutionalization,)\n\npprint([:deinstitutionalization])\n#-> [:deinstitutionalization]\n\nt = (:notation, :nation, :initialization, :intuition)\n\npprint(t)\n#-> (:notation, :nation, :initialization, :intuition)\n\npprint(collect(t))\n#-> [:notation, :nation, :initialization, :intuition]\n\npprint(resize(40), t)\n#=>\n(:notation,\n :nation,\n :initialization,\n :intuition)\n=#\n\npprint(resize(40), collect(t))\n#=>\n[:notation,\n :nation,\n :initialization,\n :intuition]\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Finally, pprint() is implemented for sets, dictionaries and named tuples.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(Dict())\n#-> Dict()\n\npprint(Set())\n#-> Set()\n\npprint((deinstitutionalization = :counterrevolutionaries,))\n#-> (deinstitutionalization = :counterrevolutionaries,)\n\npprint(Dict(:deinstitutionalization => :counterrevolutionaries))\n#-> Dict(:deinstitutionalization => :counterrevolutionaries)\n\npprint(Set([:deinstitutionalization]))\n#-> Set([:deinstitutionalization])\n\nnt = (deinstitutionalization = [:notation, :nation, :initialization, :intuition],\n      counterrevolutionaries = [:orientation, :interculture, :translucent])\n\npprint(nt)\n#=>\n(deinstitutionalization = [:notation, :nation, :initialization, :intuition],\n counterrevolutionaries = [:orientation, :interculture, :translucent])\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"The following test has to be skipped because the order of entries in a dictionary is unstable.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(Dict(pairs(nt)))\n#=>\nDict(:deinstitutionalization =>\n         [:notation, :nation, :initialization, :intuition],\n     :counterrevolutionaries => [:orientation, :interculture, :translucent])\n=#\n\npprint(Set([:deinstitutionalization, :counterrevolutionaries]))\n#-> Set([:deinstitutionalization, :counterrevolutionaries])","category":"page"},{"location":"test/#Formatting-Strings","page":"Test Suite","title":"Formatting Strings","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"The function pprint() can serialize string values.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(\"deinstitutionalization counterrevolutionaries\")\n#-> \"deinstitutionalization counterrevolutionaries\"","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"When the string contains a double quote character, pprint() may serialize it as a triple quoted literal.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), \"\\\"notation\\\", \\\"nation\\\", \\\"initialization\\\", \\\"intuition\\\".\")\n#-> \"\"\"\"notation\", \"nation\", \"initialization\", \"intuition\".\"\"\"","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Even in a triple quoted literal some \" characters must be escaped.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), \"\\\"\\\"\\\"\\\"\\\"deinstitutionalization counterrevolutionaries\\\"\\\"\\\"\\\"\\\"\")\n#-> \"\"\"\"\"\\\"\"\"deinstitutionalization counterrevolutionaries\"\"\\\"\"\\\"\"\"\"","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Triple quoted format may also be used for a multi-line string.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), \"\\\"notation\\\"\\n\\\"nation\\\"\\n\\\"initialization\\\"\\n\\\"intuition\\\"\\n\")\n#=>\n\"\"\"\n\"notation\"\n\"nation\"\n\"initialization\"\n\"intuition\"\n\"\"\"\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"For multi-line strings, escaping \" may also be necessary.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), \"\\\"\\\"\\\"\\\"\\\"deinstitutionalization\\ncounterrevolutionaries\\\"\\\"\\\"\\\"\\\"\")\n#=>\n\"\"\"\n\"\"\\\"\"\"deinstitutionalization\ncounterrevolutionaries\"\"\\\"\"\\\"\"\"\"\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"For an indented multi-line string, the indentation level must be indicated.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), \"  notation\\n  nation\\n  initialization\\n  intuition\")\n#=>\n\"\"\"\n  notation\n  nation\n  initialization\n\\x20 intuition\"\"\"\n=#","category":"page"},{"location":"test/#Using-pair_layout()","page":"Test Suite","title":"Using pair_layout()","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Function pair_layout() generates a layout expression for Pair-like objects.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"kl = literal(:deinstitutionalization)\nvl = literal(:counterrevolutionaries)\n\npl = pair_layout(kl, vl)\n\npprint(pl)\n#-> deinstitutionalization => counterrevolutionaries\n\npprint(resize(40), pl)\n#=>\ndeinstitutionalization =>\n    counterrevolutionaries\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Use parameter sep to change the separator.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(pair_layout(kl, vl, sep=\" -> \"))\n#-> deinstitutionalization -> counterrevolutionaries","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter sep_brk controls the position of the separator with respect to the line break.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), pair_layout(kl, vl, sep_brk=:start))\n#=>\ndeinstitutionalization\n    => counterrevolutionaries\n=#\n\npprint(resize(40), pair_layout(kl, vl, sep_brk=:end))\n#=>\ndeinstitutionalization =>\n    counterrevolutionaries\n=#\n\npprint(resize(40), pair_layout(kl, vl, sep_brk=:both))\n#=>\ndeinstitutionalization =>\n    => counterrevolutionaries\n=#\n\npprint(resize(40), pair_layout(kl, vl, sep_brk=:none))\n#=>\ndeinstitutionalization\n    counterrevolutionaries\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter tab specifies the indentation level.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), pair_layout(kl, vl, tab=0))\n#=>\ndeinstitutionalization =>\ncounterrevolutionaries\n=#","category":"page"},{"location":"test/#Using-list_layout()","page":"Test Suite","title":"Using list_layout()","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Function list_layout() generates a layout expression for list-like objects.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"ls = literal.([:notation, :nation, :initialization, :intuition])\n\nll = list_layout(ls)\n\npprint(ll)\n#-> (notation, nation, initialization, intuition)\n\npprint(resize(40), ll)\n#=>\n(notation,\n nation,\n initialization,\n intuition)\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Use parameter prefix to add a prefix to the list.  This is useful for generating functional notation.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(30), list_layout(ls, prefix=:deinstitutionalization))\n#=>\ndeinstitutionalization(\n    notation,\n    nation,\n    initialization,\n    intuition)\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter par specifies the left and the right parentheses.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(list_layout(ls, par=(\"[\",\"]\")))\n#-> [notation, nation, initialization, intuition]","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter sep to specifies the separator.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(list_layout(ls, sep=\" * \"))\n#-> (notation * nation * initialization * intuition)","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter sep_brk controls the position of separators with respect to line breaks.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(40), list_layout(ls, sep_brk=:start))\n#=>\n(notation\n , nation\n , initialization\n , intuition)\n=#\n\npprint(resize(40), list_layout(ls, sep_brk=:end))\n#=>\n(notation,\n nation,\n initialization,\n intuition)\n=#\n\npprint(resize(40), list_layout(ls, sep_brk=:both))\n#=>\n(notation,\n , nation,\n , initialization,\n , intuition)\n=#\n\npprint(resize(40), list_layout(ls, sep_brk=:none))\n#=>\n(notation\n nation\n initialization\n intuition)\n=#","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Parameter tab specifies the indentation level.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint(resize(30), list_layout(ls, prefix=:deinstitutionalization, tab=0))\n#=>\ndeinstitutionalization(\nnotation,\nnation,\ninitialization,\nintuition)\n=#","category":"page"},{"location":"test/#Formatting-Julia-Code","page":"Test Suite","title":"Formatting Julia Code","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"pprint() can format Expr objects.  A fairly complete subset of Julia syntax is supported.","category":"page"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"ex = quote\n    module Test\n    export f\n    using Dates\n    import Base: show\n    abstract type A{T}\n    end\n    struct S{T} <: A{T}\n        x::T\n    end\n    const v1 = [1,2,3]\n    const v2 = Number[1,2,3]\n    const t1 = (1,)\n    const t2 = (1,2,3)\n    const p = 1 => 2\n    Base.show(Base.stdout)\n    Base.@show Base.stdout\n    println(\"x = $x\")\n    \"Compute nothing\"\n    function f(::Number)\n        return\n    end\n    g(y) = y > 0 ? y : -y\n    h(args...; kw = 0) = (args, kw)\n    global G\n    if (x1 - (x2 - x3)) > ((x1 - x2) - x3)\n        if p1 && p2 || p3 && p4\n            nothing\n        elseif (p1 || p2) && (p3 || p4)\n            nothing\n        else\n            nothing\n        end\n    elseif (x1 ^ (x2 ^ x3)) <= ((x1 ^ x2) ^ x3) < x4 .+ x5\n        if !p\n            nothing\n        end\n    end\n    while x > 0\n        break\n    end\n    for t = 1:10\n        continue\n    end\n    begin\n        x = 1\n        y = 2\n        x + y\n    end\n    0 + (x = 1; y = 2; x + y)\n    let x = 1\n        x + x\n    end\n    let x = 1,\n        y = 2\n        x + y\n    end\n    quote\n        $x + $y\n    end\n    try\n        error()\n    catch err\n        nothing\n    end\n    try\n        error()\n    finally\n        nothing\n    end\n    try\n        error()\n    catch err\n        nothing\n    finally\n        nothing\n    end\n    foreach(1:10) do k\n        println(k)\n    end\n    [k for k = 1:10 if isodd(k)]\n    $(Expr(:fallback, 1, 2, 3))\n    end\nend\n\npprint(ex)\n#=>\nquote\n    module Test\n\n    export f\n\n    using Dates\n\n    import Base: show\n\n    abstract type A{T}\n    end\n\n    struct S{T} <: A{T}\n        x::T\n    end\n\n    const v1 = [1, 2, 3]\n\n    const v2 = Number[1, 2, 3]\n\n    const t1 = (1,)\n\n    const t2 = (1, 2, 3)\n\n    const p = 1 => 2\n\n    Base.show(Base.stdout)\n\n    Base.@show Base.stdout\n\n    println(\"x = $(x)\")\n\n    \"Compute nothing\"\n    function f(::Number)\n        return nothing\n    end\n\n    g(y) = y > 0 ? y : -y\n\n    h(args...; kw = 0) = (args, kw)\n\n    global G\n\n    if x1 - (x2 - x3) > x1 - x2 - x3\n        if p1 && p2 || p3 && p4\n            nothing\n        elseif (p1 || p2) && (p3 || p4)\n            nothing\n        else\n            nothing\n        end\n    elseif x1 ^ x2 ^ x3 <= (x1 ^ x2) ^ x3 < x4 .+ x5\n        if !(p)\n            nothing\n        end\n    end\n\n    while x > 0\n        break\n    end\n\n    for t = 1:10\n        continue\n    end\n\n    begin\n        x = 1\n        y = 2\n        x + y\n    end\n\n    0 + (x = 1; y = 2; x + y)\n\n    let x = 1\n        x + x\n    end\n\n    let x = 1,\n        y = 2\n        x + y\n    end\n\n    quote\n        $(x) + $(y)\n    end\n\n    try\n        error()\n    catch err\n        nothing\n    end\n\n    try\n        error()\n    finally\n        nothing\n    end\n\n    try\n        error()\n    catch err\n        nothing\n    finally\n        nothing\n    end\n\n    foreach(1:10) do k\n        println(k)\n    end\n\n    [k for k = 1:10 if isodd(k)]\n\n    $(Expr(:fallback, 1, 2, 3))\n\n    end\nend\n=#","category":"page"},{"location":"#PrettyPrinting.jl","page":"Home","title":"PrettyPrinting.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PrettyPrinting is a Julia library for optimal formatting of composite data structures.  It works by generating all possible layouts of the data, and then selecting the best layout that fits the screen width.  The algorithm for finding the optimal layout is based upon Phillip Yelland, A New Approach to Optimal Code Formatting, 2016.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Out of the box, PrettyPrinting can format Julia code and standard Julia containers.  It can be easily extended to format custom data structures.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"guide.md\", \"api.md\", \"test.md\"]","category":"page"}]
}
